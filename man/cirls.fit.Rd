% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cirls.fit.R
\name{cirls.fit}
\alias{cirls.fit}
\title{Constrained Iteratively Reweighted Least-Squares algorithm}
\usage{
cirls.fit(x, y, weights = rep.int(1, nobs), start = NULL,
  etastart = NULL, mustart = NULL, offset = rep.int(0, nobs),
  family = stats::gaussian(), control = list(), intercept = TRUE,
  singular.ok = TRUE)
}
\arguments{
\item{x, y}{\code{x} is a design matrix and \code{y} is a vector of response observations. Usually internally computed by \link[stats:glm]{glm}.}

\item{weights}{An optional vector of observation weights.}

\item{start}{Starting values for the parameters in the linear predictor.}

\item{etastart}{Starting values for the linear predictor.}

\item{mustart}{Starting values for the vector or means.}

\item{offset}{An optional vector specifying a known component in the model. See \link[stats:model.extract]{model.offset}.}

\item{family}{The result of a call to a family function, describing the error distribution and link function of the model. See \link[stats:family]{family} for details of available family functions.}

\item{control}{A list of parameters controlling the fitting process. See details and \link[=cirls.control]{cirls.control}.}

\item{intercept}{Logical. Should an intercept be included in the null model?}

\item{singular.ok}{Logical. If \code{FALSE}, the function returns an error for singular fits.}
}
\value{
A object of class \code{cirls} inheriting from \code{glm}. The object of class \code{cirls} includes all components from \link[stats:glm]{glm} objects, with the addition of:
\item{Cmat, lb, ub}{the constraint matrix, and lower and upper bound vectors. If provided as lists, the full expanded matrix and vectors are returned.}
\item{active.cons}{vector of indices of the active constraints in the fitted model.}
\item{inner.iter}{number of iterations performed by the last call to the QP solver.}
\item{etastart}{the initialisation of the linear predictor \code{eta}. The same as \code{etastart} when provided.}
\item{singular.ok}{the value of the \code{singular.ok} argument.}

Any method for \code{glm} objects can be used on \code{cirls} objects.
}
\description{
Routine implementing the constrained iteratively-reweighted least-squares (CIRLS) algorithm to fit generalised linear models (GLM) with linear constraints on the coefficients. This function is designed to replace the \code{glm.fit} function passed through the \code{method} argument of \link[stats:glm]{glm}.
}
\details{
This function is a plug-in for \link[stats:glm]{glm} and works similarly to \link[stats:glm]{glm.fit}. In addition to the parameters already available in \link[stats:glm]{glm.fit}, \code{cirls.fit} allows the specification of constraints through different arguments (see \link[=buildCmat]{buildCmat}). These additional parameters can be passed through the \code{control} list or through \code{...} in \link[stats:glm]{glm} \emph{but not both}. If any parameter is passed through \code{control}, then \code{...} will be ignored. See the full list of parameters in \link[=cirls.control]{cirls.control}.
\subsection{Algorithm}{

The CIRLS algorithm is a modification of the classical IRLS algorithm in which each update of the regression coefficients is performed by a quadratic program (QP), ensuring the update stays within the feasible region defined by \code{Cmat}, \code{lb} and \code{ub}. More specifically, this feasible region is defined as

\verb{lb <= Cmat \%*\% coefficients <= ub}

where \code{coefficients} is the coefficient vector returned by the model. This specification allows for any linear constraint, including equality ones.
}
}
\examples{
###############################################################################
# Non-negative coefficient example with the london dataset

library(splines)

### Association between CO and mortality
# Model includes spline of date and day-of-year
# Nonnegative constraint on CO
model <- glm(death ~ co + weekdays(date) + ns(date, df = 7*8),
  data = london, family = "quasipoisson",
  method = "cirls.fit", cons = ~ shape(co, "pos"))

# Coefficient and confidence interval
coef(model)[2]
confint(model)[2,]

###############################################################################
# Monotone strata levels with the warming dataset

### Fit the model

# Define decadal strata (as a factor)
warming$decade <- factor(10 * floor(warming$year / 10))

# Non-decreasing constraint on decadal strata
model <- glm(anomaly ~ decade, data = warming, method = "cirls.fit",
  cons = ~ shape(decade, "inc"))

# Plot result
plot(anomaly ~ year, data = warming, xlab = "", ylab = "Temperature anomaly")
lines(warming$year, predict(model), col = 2, lwd = 2)

### Extract results

# Coefficients and confidence intervals
betas <- coef(model)
v <- vcov(model)
cis <- confint(model)

# Degrees of freedom: represent number of strata change
# ?edf
edf(model)

### Compare with an unconstrained model

# Refit the model
umodel <- uncons(model)

# Add result
lines(warming$year, predict(umodel), col = 3, lwd = 2, lty = 2)

##############################################################################
# Monotone splines with the warming dataset

library(splines)

# Define a natural spline basis
basis <- ns(warming$year, df = 10)

### Constrained model

# Non-decreasing splines
model <- glm(anomaly ~ basis, data = warming, method = "cirls.fit",
  cons = ~ shape(basis, "inc"))

# Plot result
plot(anomaly ~ year, data = warming, xlab = "", ylab = "Temperature anomaly")
lines(warming$year, predict(model), col = 2, lwd = 2)

### Unconstrained model
umodel <- uncons(model)
lines(warming$year, predict(umodel), col = 3, lwd = 2, lty = 2)

###############################################################################
# Compositional regression example with the fgl dataset

# Add a small increment to zeros
x <- as.matrix(fgl[,2:9])
x[x == 0] <- min(x[x > 0]) / 2

# Normalise to unit sum and take log
z <- log(x / rowSums(x))

# Fit model
model <- glm(RI ~ z, data = fgl, method = "cirls.fit",
  cons = ~ zerosum(z))

# Coefficients and confidence intervals
coef(model)
confint(model)
}
\references{
Goldfarb, D., Idnani, A., 1983. A numerically stable dual method for solving strictly convex quadratic programs. \emph{Mathematical Programming} \strong{27}, 1–33. \href{https://doi.org/10.1007/BF02591962}{DOI:10.1007/BF02591962}

Meyer, M.C., 2013. A Simple New Algorithm for Quadratic Programming with Applications in Statistics. \emph{Communications in Statistics - Simulation and Computation} \strong{42}, 1126–1139. \href{https://doi.org/10.1080/03610918.2012.659820}{DOI:10.1080/03610918.2012.659820}

Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S., 2020. OSQP: an operator splitting solver for quadratic programs. \emph{Math. Prog. Comp.} \strong{12}, 637–672. \href{https://doi.org/10.1007/s12532-020-00179-2}{DOI:10.1007/s12532-020-00179-2}
}
\seealso{
\link[=buildCmat]{buildCmat} for details on constraint specification and \link[=cirls.control]{cirls.control} for parameters controlling the algorithm. \link[stats:glm]{glm} provides details on \code{glm} objects.
}
